1. synchronized 是一种互斥锁 （互斥锁 --> 意味着最多只有一个线程能够获得该锁）
2. java中的每个对象都有一个内置锁（monitor 监视器 也可以理解成锁标记）
   而synchronized就是使用对象的内置锁来将代码块（资源）锁定的
   
   synchronized线程的原子性(被保护的代码块是一次被执行的，没有任何线程会同时访问)
             与线程的可见性(当执行完synchronized之后，修改后的变量对其他的线程是可见的)
   synchronized的静态方法使用的是类锁， 代码块和非静态方法使用的是对象锁   
            
重入锁  https://juejin.im/entry/5933d6fb2f301e006bfc10f5
 synchronized就是一种重入锁，当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功

显示锁 （Lock显式锁）

### 独占锁
1. 独占锁模式下，每次只能有一个线程能持有锁
2. ReentrantLock就是以独占方式实现的互斥锁

> 很显然，独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，
  这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性

### 共享锁
1. 共享锁，则允许多个线程同时获取锁，并发访问 共享资源
2. 如：ReadWriteLock

> 共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 
  java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，
  但两者不能同时进行

### 公平锁 与 非公平锁
1. 锁的公平与非公平，是指线程请求获取锁的过程中，是否允许插队
2. 在公平锁上，线程将按他们发出请求的顺序来获得锁
3. 而非公平锁则允许在线程发出请求后立即尝试获取锁，如果可用则可直接获取锁，尝试失败才进行排队等待

> ReentrantLock提供了两种锁获取方式，FairSyn和NofairSync。
  结论：ReentrantLock是以独占锁的加锁策略实现的互斥锁，同时它提供了公平和非公平两种锁获取方式



锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁